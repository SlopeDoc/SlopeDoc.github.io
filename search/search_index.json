{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Slope?","text":"<p>Exporting scientific results or complicated concepts into pretty presentations is a very hard proces that very often leads to a sad succession of screenshots and equations.</p> <p>But talking about graphics and geometry without 3D is both a waste of joy and clarity.</p> <p>Hence we propose Slope, a 3D slide engine built on top of Polyscope, which can be loaded on top of your scientific code!</p> <p>The goal is to allow researchers, teachers and geometry lovers to easily illustrate concepts with pretty &amp; interactive 3D slides and animations.</p>    Your browser does not support the video tag."},{"location":"#main-features","title":"Main features:","text":"<ul> <li>Easy integration of all polyscope primitives and quantities</li> <li>LateX compilation, with possible hot-reloading</li> <li>Intuitive slide creation system</li> <li>Full control over objects and animations</li> <li>Automatic transitions</li> <li>Interactivity with ImGui widgets</li> </ul>"},{"location":"#presentations-with-slope","title":"Presentations with Slope:","text":"<p>Here is a link to a youtube playlist containing presentations with Slope : link. Please let me know if you want to add your presentation to the list!</p>"},{"location":"about/","title":"About","text":"<p>Slope is mainly developped by Baptiste Genest.</p> <p>Any help is welcome! In particular regarding clean software engineering (really not my specialty).</p>"},{"location":"about/#contributors","title":"Contributors:","text":"<ul> <li>David Coeurjolly</li> </ul>"},{"location":"cmake/","title":"Build & CMake Integration","text":"<p>Slope is designed to be easilty integrated on top of any cmake project in order to merge scientific code and your presentations!</p> In CMakeLists.txtFetchContent file <pre><code>project(slope_project)\ncmake_minimum_required(VERSION 3.12)\n\nlist(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\ninclude(slope)\n\nadd_executable(slope_project slides.cpp )\ntarget_link_libraries(slope_project slope)\n</code></pre> slope.cmake<pre><code>include(FetchContent)\nFetchContent_Declare(\n  slope\n  GIT_REPOSITORY https://github.com/baptiste-genest/slope.git\n  GIT_TAG alpha-0.0.1\n)\nFetchContent_MakeAvailable(slope)\n</code></pre>"},{"location":"cmake/#dependencies","title":"Dependencies","text":"<ul> <li>the same as Polyscope</li> <li>Imagick (<code>convert</code> command) : Make sure that the convert command is allowed to convert pdf to png, see here.</li> <li><code>pdflatex</code></li> </ul> <p>Paths to Imagick and pdflatex are found by cmake.</p>"},{"location":"cmake/#build-and-run","title":"Build and run !","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake -j\n./exe --project_path /path/to/your/project/folder\n</code></pre>"},{"location":"interactivity/","title":"Interactivity & Widgets","text":"<p>Since Slope works on top of polyscope, you keep the control over the camera with usual mouse control.</p> <p>To make interactive presentations, you can use ImGui widgets as a primitive: <pre><code>    float* f = new float(1); // make sure to allocate on heap\n\n    show &lt;&lt; Point::Add([f](TimeObject t) {\n        scalar th = (*f)*t.inner_time;\n        return vec(cos(th),sin(th),0);\n    });\n\n    show &lt;&lt; ImGuiWidgets::Add([f]() {\n        ImGui::SliderFloat(\"speed\",f,0,10);\n    },\"window name\");\n</code></pre></p> <p><code>ImGuiWidgets::Add(std::function&lt;void()&gt;&amp; callback,std::string window_name)</code></p>    Your browser does not support the video tag."},{"location":"limitations/","title":"Limitations","text":"<p>Before giving it a try, be aware of the following limitations:</p> <ul> <li>Making slides with Slope can be very time consuming, having to recompile at each change takes a lot of time. (Happily, the result is often worth it )</li> <li>Since it is only built on top of Polyscope, we share its features and its (few) limitations: no multi-view compositing, no shadows, etc...</li> <li>Slope is mainly poorly written, it was a small side project to give a lecture about differential geometry that turned into my main tool for presentations, but many design patterns are dark ones, so it may impact long term developpement... Feel free to indicate ways to upgrade the code quality or to contribute!</li> <li>We also share the general limitations of litterate programming, hence combining slides from different talks can be painful if you use scientific code. To alleviate this issue, slope offers ways to import/export data.</li> <li>If the conference you are presenting at has the terrible policy of not allowing presentations on your own laptop, or if you want to share your slides, you may turn them into a PDF, but nothing is automatic (yet). You have to manually screenshot each slide (at the time you see fit for the animations), by pressing <code>p</code>, and then concatenate them into a pdf.</li> </ul>"},{"location":"options/","title":"Paths, Caches & Options","text":""},{"location":"options/#main-paths","title":"Main paths","text":"<p>In order to simplify resource fetching and relative paths, multiple paths must be carefully set, either via CLI or in the main if needed:</p> <p><code>std::string ProjectPath</code></p> <p>path from executable to current's project folder, must be set via CLI: <pre><code>./project_exe --project_path /home/.../slope_project\n</code></pre></p> <code>std::string ProjectDataPath</code> <p>path prefix for where to fetch data, by default equal to <code>ProjectPath</code>. When loading an external data, it the given path is relative it will take this as a referential.</p> <code>std::string CachePath</code> <p>Where to store stuff that is generated by slope, like latex images or GIF decomposition. By default in the build file.</p> <p><code>std::string ProjectViewsPath</code></p> <p>Where to store the persistant quantities like persistant positions or camera views. By default will create a <code>views</code> folder in the <code>ProjectPath</code> (so that it is preserved in a git for instance).</p> <p>Some other important variables can be set in the main file</p>"},{"location":"options/#paths-to-dependancies","title":"Paths to dependancies","text":"<p>The path to <code>pdflatex</code> and <code>convert</code> tools are automatically fetched by cmake but you can change them if needed:</p> <p><code>std::string PathToPDFLATEX</code></p> <p><code>std::string PathToConvert</code></p>"},{"location":"options/#screen-resolution","title":"Screen resolution","text":"<p>All coordinates in slope are expressed in a relative manner wrt to screen size, in order to match your resolution, you can specify it by CLI, or set it via global variables:</p> <pre><code>./project_exe --project_path /home/.../slope_project --resolution 500x800\n</code></pre> <p><code>size_t ScreenResolutionWidth</code></p> <p><code>size_t ScreenResolutionHeight</code></p>"},{"location":"options/#misc","title":"Misc","text":"<p><code>Eigen::Vector3d DefaultBackgroundColor</code> (rgb 0-1)</p>"},{"location":"Primitives/Animation/","title":"Animation","text":"<p>The way animations can be programatically conceived is through updaters.</p> <p>All primitives have an updater object that is called at each frame such that each primitive can be time-dependant:</p> <pre><code>auto pc = PointCloud::Add(positions);\npc-&gt;updater = [pc] (TimeObject t,Primitive*) {\n\n    if (t.relative_frame == 0) {\n        auto P = pc-&gt;getPoints();\n        for (auto&amp; x : P) \n            x(0) += std::sin(t.inner_time);\n        pc-&gt;updateCloud(P);\n    } else if (t.relative_frame == 1) {\n        // do something else\n    }\n}\n</code></pre> <p><code>TimeObject</code></p> <p>The TimeObject given in parameter of the updater contains all relevant time information for each primitive:</p> <ul> <li><code>from_begin</code> (s) : time from start of the program</li> <li><code>from_action</code> (s) : time from last slide change</li> <li><code>inner_time</code> (s) : time from first appearence on screen</li> <li><code>absolute_frame_number</code> (int) : current frame number from first slide</li> <li><code>relative_frame_number</code> (int) : number of slides from first appearence of this primitive</li> </ul>"},{"location":"Primitives/Gifs/","title":"Gifs","text":"<p>As screen primitives are rendered with ImGui, no video support is possible but one can load gifs instead:</p> <pre><code>show &lt;&lt; Gif::Add(\"puppy_dance.gif\");\n</code></pre>"},{"location":"Primitives/Gifs/#builder","title":"Builder","text":"<code>c++ Gif::Add(std::string path, int fps,float scale,bool loop);</code> <ul> <li><code>std::string path</code> if relative then look in data path.</li> <li><code>int fps</code> speed at which the gif is played (default: 10 fps)</li> <li><code>float scale</code> gif scale</li> <li><code>bool loop</code> does the gif repeat (default: true)</li> </ul> <p>Warning</p> <p>Gifs are simply decomposed in images (in a cache) and then rendered sequentially, hence it easily takes a lot of space.</p>"},{"location":"Primitives/Mesh/","title":"Mesh","text":"<p>What would we do without meshes? You can load one either from a file or a handmade one:</p>"},{"location":"Primitives/Mesh/#builders","title":"Builders","text":"<code>c++ Mesh::Add(std::string path, float scale,bool smooth = true);</code> <ul> <li><code>std::string path</code> if relative then look in data path.</li> <li><code>float scale</code> scale </li> <li><code>bool smooth</code> polyscope shading mode (if false then visible edges)</li> </ul> <code>c++ Mesh::Add(const vecs&amp; V,const faces&amp; F, bool smooth = true);</code> <ul> <li><code>const vecs&amp; V</code> vecs = <code>std::vector&lt;Eigen::Vector3d&gt;</code>.</li> <li><code>const faces&amp; F</code> faces = <code>std::vector&lt;std::vector&lt;size_t&gt;</code>.</li> <li><code>bool smooth</code> polyscope shading mode (if false then visible edges)</li> </ul>"},{"location":"Primitives/camera/","title":"Camera placement","text":"<p>Just as for text, setting the camera programmatically would be very unpleasant. Hence, when creating your slides, you can save at any time the current  state of the camera, by pressing <code>C</code>, under a key name (must be unique), which can then be loaded in the code:</p>"},{"location":"Primitives/camera/#builder","title":"Builder","text":"<code>CameraView::Add(std::string key, bool flyTo = false)</code> <p>Pretty transitions between cameras is possible using the FlyTo options:</p>"},{"location":"Primitives/images/","title":"Images","text":"<p>Most basic screen primitive.</p> <pre><code>show &lt;&lt; Image::Add(\"slope_logo.png\");\n</code></pre>"},{"location":"Primitives/images/#builder","title":"Builder","text":"<p><code>c++ Image::Add(std::string path,float scale);</code></p>"},{"location":"Primitives/point_cloud/","title":"Point Clouds","text":"<p>What would we do without point clouds? You can load one as simple as:</p>"},{"location":"Primitives/point_cloud/#builders","title":"Builders","text":"<code>c++ PointCloud::Add(const vecs&amp; X,scalar radius = -1);</code> <ul> <li><code>const vecs&amp; X</code> <code>std::vector&lt;Eigen::Vector3d&gt;</code></li> <li><code>float radius</code> point cloud radius (not relative), if not set then polyscope default radius is used</li> </ul>"},{"location":"Primitives/point_cloud/#single-point","title":"Single Point","text":"<p>A single point, with more features, can be added using</p> <p><code>c++ Point::Add(const vec&amp; x,scalar radius = -1);</code></p> <code>c++ Point::Add(const DynamicParam&amp; x,scalar radius = -1);</code> <ul> <li><code>DynamicParam = std::function&lt;vec(TimeObject)&gt;</code> the point follows a time dependent (wrapper for its updater)</li> </ul> <code>VectorFieldQuantity Point-&gt;addVector(const vec&amp; v)</code> <ul> <li>attachs a vector to the point, see polyscope quantites</li> </ul>"},{"location":"Primitives/polyscope_primitives/","title":"Basics","text":"<ul> <li>Point cloud</li> <li>Mesh</li> <li>Curve3D</li> <li>Camera view</li> <li>Polyscope quantites</li> </ul> <p>Polyscope primitives live in a common 3D referential.</p> <p>You can edit all the properties of the polyscope object this way:</p> <pre><code>    auto M = Mesh::Add(\"bunny.obj\");\n    M-&gt;pc-&gt;setSurfaceColor(glm::vec3(1,0,0));\n    show &lt;&lt; M; //red bunny\n</code></pre>"},{"location":"Primitives/quantities/","title":"Polyscope Quantities","text":"<p>The most appealing feature of polyscope is arguably being able to visualize all kind of fields (of scalars or vectors).</p> <p>Of course, during the presentation, one would like to control independently the quantity being visualized and the primitive it belongs to.</p> <p>One can do it simply in the following way: <pre><code>    auto mesh = Mesh::Add(\"bunny.obj\");\n\n    Vec V = // some scalar field of size = nb vertex;\n\n    auto sf = mesh-&gt;pc-&gt;addVertexScalarQuantity(\"some field\",V);\n\n    sf-&gt;q-&gt;setColorMap(\"viridis\"); //access polyscope structure\n\n    auto field = AddPolyscopeQuantity(sf);\n\n    // displays mesh first, then the scalar field\n    show &lt;&lt; mesh &lt;&lt; InNextFrame &lt;&lt; field;\n</code></pre></p>"},{"location":"Primitives/screen_primitives/","title":"Basics","text":""},{"location":"Primitives/screen_primitives/#screen-primitives","title":"Screen Primitives","text":"<ul> <li>Image</li> <li>Gif</li> <li>Latex</li> </ul> <p>Screen primitives can be placed on the screen using various 2D referential, with the <code>at</code> method (see Placement).</p>"},{"location":"Primitives/transforms/","title":"Transforms","text":"<p>The object to scene transform can be set with: <pre><code>    auto M = Mesh::Add(\"bunny.obj\");\n    M-&gt;localTransform = Transform::ScalePositionRotate(...);\n</code></pre></p> <p>Each object transform can be controled on each slide with the <code>at</code> method: <pre><code>    show &lt;&lt; M-&gt;at(vec(1,1,1)) // same as at(Transform::Translation(x));\n    show &lt;&lt; inNextFrame &lt;&lt; M-&gt;at(vec(-1,-1,-1)); // will transition between transforms\n</code></pre></p>"},{"location":"Primitives/transforms/#persistent-transform-and-live-editing","title":"Persistent transform and live editing","text":"<p>Just as for Persistent 2D positions, setting a label allows to modify the transform in live: <pre><code>    show &lt;&lt; M-&gt;(\"bunny\");\n</code></pre> by pressing <code>t</code>.</p>"},{"location":"Primitives/transforms/#builders","title":"Builders","text":"<p><code>Transform Translation(const vec&amp; x)</code></p> <p><code>Transform AxisAngle(scalar th, vec x)</code></p> <p><code>Transform Scale(const vec&amp; x)</code></p> <p><code>Transform Scale(scalar s)</code></p> <p><code>Transform ScalePositionRotate(const vec&amp; s,const vec&amp; p,vec axis,scalar th)</code></p> <p><code>Transform ScalePositionRotate(const vec&amp; s,const vec&amp; p,const mat&amp; R)</code></p>"},{"location":"Primitives/Latex/dynamic/","title":"Hot Reloading","text":"<p>When creating the slides, text is more often edited than the rest. In order to avoid recompiling, hot reloading of an external source file is possible.</p> Json LateX sourceCode <pre><code>{\n\"key1\":[0,\"Some text\",1],\n\"key2\":[1,\"\\pi \\approx 3\",1]\n}\n</code></pre> <pre><code>LatexLoader::Init(\"latex.json\");\n\nshow &lt;&lt; LatexLoader::Load(\"key1\");\n\n// equivalent to LatexLoader::Load(\"key2\")-&gt;at(\"key2\")\nshow &lt;&lt; LatexLoader::LoadWithKey(\"key2\");  \n</code></pre> <p>In the Json, the first element must be 0 or 1, 0 for text, 1 for formulas, the middle one is the content, the last one is the scale of the text.</p> <p>Warning</p> <p>The reloading occurs when the json file is saved, if there is an error in the LateX, the program will end.</p>    Your browser does not support the video tag."},{"location":"Primitives/Latex/latex/","title":"Basics","text":"<p>In order to add text on your slides, you can add Latex, either by hardcoding it in the program, or by loading it from an external source (recommended).</p> <p>To make things easier between standard text and formulas, two builders exist:</p> <pre><code>    show &lt;&lt; Latex::Add(\"Some text, can use math $\\\\pi$\");\n    show &lt;&lt; Formula::Add(\"\\\\int_0^1 t dt = 8\"); // math mode by default\n</code></pre> <p>Importing latex packages can be easily done using:</p> <pre><code>    Latex::AddToPrefix(\"\\\\usepackage{libertine}\"); \n    // will be added before ALL latex objects\n</code></pre> <p>Latex files are then hashed and stored in a cache to only generate them once.</p> <p>Full string escape</p> <p>For complex strings, escaping each \\ is painfull, remember that C++ offers full string escaping: <pre><code>Latex::Add(R\"( much easier like that : $\\pi = \\int_0^3 1 dt$ )\")    \n</code></pre></p> <p>Image resolution</p> <p>Slope naively converts latex pdf to png, hence we lose the scale invariance of vector graphics. If you want to scale some text to very large you can change the DPI for the conversion, by setting <code>slope::Options::PDFtoPNGDensity</code>.</p>"},{"location":"Primitives/Latex/titles/","title":"Titles","text":"<p>As titles are a special kind of text, you can use the <code>Title(std::string text)</code> wrapper, it creates a (special) latex object that is larger by default and is unique: if a new title is added to a slide it will replace the previous one. <pre><code>    show &lt;&lt; Title(\"This is a title\");\n    // add some stuff\n    show &lt;&lt; inNextFrame &lt;&lt; Title(\"This is the new title\"); //everything is copied but the title is replaced\n    show &lt;&lt; newFrameSameTitle;// everything is removed except the title \n</code></pre></p>"},{"location":"Primitives/Latex/titles/#table-of-contents","title":"Table of contents","text":"<p>As titles are unique, you can use them to jump between slides: by pressing <code>tab</code> you get the list of all titles and clicking on one will make you jump directly to the first slide with this title, useful for questions during presentations!</p> <p>It is then good practice that each slide has a title (or else it will appear in the table of contents as its slide number).</p>"},{"location":"placement/absolute/","title":"Absolute","text":"<p>The simplest way to place a screen primitive in a slide is through absolute placement (expressed in relative coordinates): <pre><code>    // place at half of the width and 20% of the height, from the bottom-left\n    show &lt;&lt; Image::Add(\"dog.png\")-&gt;at(0.5,0.2); \n</code></pre></p> <p>For common positions, many wrappers exist:</p> <pre><code>    show &lt;&lt; Title(\"absolute\")-&gt;at(TOP); // also exist with CENTER and BOTTOM\n    show &lt;&lt; PlaceLeft(ptr,y_coord,offset); \n    show &lt;&lt; PlaceRight(ptr,y_coord,offset); \n    show &lt;&lt; PlaceBottom(ptr,x_coord,offset); \n    show &lt;&lt; PlaceTop(ptr,x_coord,offset); \n</code></pre>"},{"location":"placement/persistant_placement/","title":"Persistent","text":"<p>Eyeballing positions on the screen can be tedious, hence, you can instead assign a label to a primitive (possibly a different one per slide).</p> <p>Labeled pritmives can then be selected, with <code>Ctrl+Left Click</code>, and be moved with the mouse and scaled with the mouse roll. The assigned position will by saved for future executions. A selected primitive can be centered horizontally by pressing <code>H</code> and vertically by pressing <code>V</code>.</p> <pre><code>    show &lt;&lt; slope_logo-&gt;at(\"label1\");\n    show &lt;&lt; inNextFrame &lt;&lt; slope_logo-&gt;at(\"label2\"); // will move from label1 pos to label2 pos\n</code></pre> <p>Warning</p> <p>Labels must be unique, if you set the same label to another primitive, they will share the same position (can be usefull to replace a primitive by another one).</p>"},{"location":"placement/relative_placement/","title":"Relative","text":"<p>Primitives can be placed with respect to another one. The main way to do so is with:</p> <p><code>PlaceRelative(ScreenPrimitivePtr A,ScreenPrimitivePtr other,placeX X,placeY Y,scalar paddingX,scalar paddingY)</code></p> <ul> <li><code>ScreenPrimitivePtr A</code> primitive to place wrt to B</li> <li><code>ScreenPrimitivePtr other</code> reference Primitive</li> <li><code>placeX X</code> can be:  <code>REL_LEFT, ABS_LEFT, CENTER_X,SAME_X,REL_RIGHT,ABS_RIGHT</code> for example <code>REL_X</code> will place A to the left of B, <code>ABS_RIGHT</code> will place A to the right of the screen</li> <li><code>placeY Y</code> can be:  <code>REL_TOP, ABS_TOP, CENTER_Y,SAME_Y,REL_BOTTOM,ABS_BOTTOM</code></li> <li><code>scalar paddingX</code> offset in the opposite direction of the placeX in the x-coord</li> <li><code>scalar paddingY</code> offset in the opposite direction of the placeY in the x-coord</li> </ul> <p>Dynamic tracking</p> <p> </p> <p>The relative placement is dynamic, if the reference primitive moves, the placement is updated: <pre><code>    show &lt;&lt; Latex::Add(\"I'm A\")-&gt;at(\"A\");\n    show &lt;&lt; PlaceBelow(Latex::Add(\"I follow A\"),0.03);\n</code></pre></p> <p>Of course, many wrappers exist over this to simplify stuff for common constructions:</p>"},{"location":"placement/relative_placement/#wrappers","title":"Wrappers:","text":"<code>PlaceNextTo(ScreenPrimitivePtr ptr,int side,scalar paddingx = 0.01,ScreenPrimitivePtr other = nullptr)</code> <p>side 0 = left, side 1 = right</p> <p><code>PlaceBelow(ScreenPrimitivePtr ptr,ScreenPrimitivePtr other,scalar paddingy = 0.01)</code></p> <p><code>PlaceAbove(ScreenPrimitivePtr ptr,ScreenPrimitivePtr other,scalar paddingy = 0.01)</code></p> <p>Last primitive inserted</p> <p>If you don't specify <code>other</code>, then it will use as reference the last screen primitive inserted in the slide. <pre><code>show &lt;&lt; Title(\"Relative is better\")-&gt;at(TOP);\nshow &lt;&lt; PlaceBelow(Latex::Add(\"sub title\"),0.1); // will place below title\n</code></pre></p>"},{"location":"placement/tracking/","title":"World to screen tracking","text":"<p>You can force a 2D object, for instance a label, to follow a 3D object of the scene using the <code>screenprimtiveptr-&gt;track</code> method.</p> <p><code>track(const std::function&lt;vec()&gt;&amp; placer,vec2 offset)</code></p> <ul> <li><code>const std::function&lt;vec()&gt;&amp; placer</code> should return the 3D position to follow, the lambda is intended to capture the element to follow, see Example.</li> <li><code>vec2 offset</code> displacement on the screen from the projected 3D position, expressed in relative coordinates (i.e. <code>vec2(0.1,0.2)</code> means an offset of 10% of the screen width and 20% of the screen height)</li> </ul>"},{"location":"placement/tracking/#example","title":"Example","text":"<pre><code>    auto particle = Point::Add([] (TimeObject t) -&gt; vec {\n        float angle = t.inner_time;\n        return vec(cos(angle), sin(angle), 0);\n    });\n\n    show &lt;&lt; particle;\n\n    show &lt;&lt; Formula::Add(\"x\")-&gt;track([particle] () {return particle-&gt;getCurrentPos();}, vec2(0.03,0.03));\n</code></pre> <p>A fixed point in the 3D scene can also be followed:</p> <p><code>at(const vec&amp; pos,vec2 offset)</code></p>"},{"location":"workflow/full_example/","title":"Step by step example","text":"<p>Starting only from pure documentation can be hard so here is a step by step example to handle the core concepts of slope!</p> Project Template<pre><code>#include \"slope.h\"\n\nusing namespace slope;\n\nSlideshow show;\n\nvoid CreateSlides() {\n\n\n}\n\n\n\nint main(int argc,char** argv) {\n    show.init(\"My first slope project\",argc,argv);\n    CreateSlides();\n    show.run();\n    return 0;\n}\n</code></pre>"},{"location":"workflow/slide/","title":"Slide management","text":"<p>The way the user adds elements to the slides is with streams <code>&lt;&lt;</code></p> <p>The core object is the <code>Slideshow</code> object that must be unique for each presentation.</p>"},{"location":"workflow/slide/#adding-elements","title":"Adding elements","text":"<p>Adding elements to the current slide is simply: <pre><code>    Slideshow show;\n    show &lt;&lt; Mesh::Add(\"bunny.obj\");\n</code></pre></p>"},{"location":"workflow/slide/#sequencing","title":"Sequencing","text":"<p>If you want elements to appear not all at the same time, you must use <code>inNextFrame</code>:</p> <pre><code>    show &lt;&lt; Mesh::Add(\"bunny.obj\");\n    show &lt;&lt; inNextFrame &lt;&lt; Latex::Add(\"A bunny\")-&gt;at(\"bunny\"); // will appear in the next slide\n</code></pre> <p>If you want to remove an object in the next slide, you can use <code>&gt;&gt;</code>: <pre><code>    auto bunny = Mesh::Add(\"bunny.obj\");\n    show &lt;&lt; Title(\"The bunny disappears!\")-&gt;at(TOP) &lt;&lt; bunny;\n    show &lt;&lt; inNextFrame &gt;&gt; bunny; // Title remains but bunny fades away ;-(\n</code></pre></p>"},{"location":"workflow/slide/#new-slide","title":"New slide","text":"<p>To switch to the next slide, you must use <code>newFrame</code>:</p> <pre><code>    show &lt;&lt; Title(\"My first slide\")-&gt;at(CENTER);  \n    show &lt;&lt; PointCloud::Add(X);\n    show &lt;&lt; newFrame &lt;&lt; Title(\"My second slide\")-&gt;at(TOP); // new slide only contains new title\n</code></pre>"},{"location":"workflow/transitions/","title":"Automatic transitions","text":"<p>Slope handles automatically fade in/fade out, and primitive displacement between slides.</p> <p>To do so, there is a distinction between a Primitive, which is a unique object, and a Primitive placed in a slide.</p> <p>The difference being that if a primitive is present in a slide at a given location, and in the next slide at another location, the transition will be generated between the two:</p> <p><pre><code>    auto text = Title(\"follow me\");\n    show &lt;&lt; text-&gt;at(TOP);\n    show &lt;&lt; inNextFrame &lt;&lt; text-&gt;at(BOTTOM); // text will slide from top to bot\n</code></pre> In this example the title is duplicated by <code>inNextFrame</code> but when you reinsert it, the new location overrides the old one.</p>    Your browser does not support the video tag."}]}